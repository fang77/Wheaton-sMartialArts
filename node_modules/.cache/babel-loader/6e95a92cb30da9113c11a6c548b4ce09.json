{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _helpers = require('../helpers');\n\nvar loadPage = function loadPage(data, popstate) {\n  var _this = this; // create array for storing animation promises\n\n\n  var animationPromises = [],\n      xhrPromise = void 0;\n\n  var animateOut = function animateOut() {\n    _this.triggerEvent('animationOutStart'); // handle classes\n\n\n    document.documentElement.classList.add('is-changing');\n    document.documentElement.classList.add('is-leaving');\n    document.documentElement.classList.add('is-animating');\n\n    if (popstate) {\n      document.documentElement.classList.add('is-popstate');\n    }\n\n    document.documentElement.classList.add('to-' + (0, _helpers.classify)(data.url)); // animation promise stuff\n\n    animationPromises = _this.getAnimationPromises('out');\n    Promise.all(animationPromises).then(function () {\n      _this.triggerEvent('animationOutDone');\n    }); // create history record if this is not a popstate call\n\n    if (!popstate) {\n      // create pop element with or without anchor\n      var state = void 0;\n\n      if (_this.scrollToElement != null) {\n        state = data.url + _this.scrollToElement;\n      } else {\n        state = data.url;\n      }\n\n      (0, _helpers.createHistoryRecord)(state);\n    }\n  };\n\n  this.triggerEvent('transitionStart', popstate); // set transition object\n\n  if (data.customTransition != null) {\n    this.updateTransition(window.location.pathname, data.url, data.customTransition);\n    document.documentElement.classList.add('to-' + (0, _helpers.classify)(data.customTransition));\n  } else {\n    this.updateTransition(window.location.pathname, data.url);\n  } // start/skip animation\n\n\n  if (!popstate || this.options.animateHistoryBrowsing) {\n    animateOut();\n  } else {\n    this.triggerEvent('animationSkipped');\n  } // start/skip loading of page\n\n\n  if (this.cache.exists(data.url)) {\n    xhrPromise = new Promise(function (resolve) {\n      resolve();\n    });\n    this.triggerEvent('pageRetrievedFromCache');\n  } else {\n    if (!this.preloadPromise || this.preloadPromise.route != data.url) {\n      xhrPromise = new Promise(function (resolve, reject) {\n        (0, _helpers.fetch)(_extends({}, data, {\n          headers: _this.options.requestHeaders\n        }), function (response) {\n          if (response.status === 500) {\n            _this.triggerEvent('serverError');\n\n            reject(data.url);\n            return;\n          } else {\n            // get json data\n            var page = _this.getPageData(response);\n\n            if (page != null) {\n              page.url = data.url;\n            } else {\n              reject(data.url);\n              return;\n            } // render page\n\n\n            _this.cache.cacheUrl(page);\n\n            _this.triggerEvent('pageLoaded');\n          }\n\n          resolve();\n        });\n      });\n    } else {\n      xhrPromise = this.preloadPromise;\n    }\n  } // when everything is ready, handle the outcome\n\n\n  Promise.all(animationPromises.concat([xhrPromise])).then(function () {\n    // render page\n    _this.renderPage(_this.cache.getPage(data.url), popstate);\n\n    _this.preloadPromise = null;\n  }).catch(function (errorUrl) {\n    // rewrite the skipPopStateHandling function to redirect manually when the history.go is processed\n    _this.options.skipPopStateHandling = function () {\n      window.location = errorUrl;\n      return true;\n    }; // go back to the actual page were still at\n\n\n    window.history.go(-1);\n  });\n};\n\nexports.default = loadPage;","map":null,"metadata":{},"sourceType":"script"}